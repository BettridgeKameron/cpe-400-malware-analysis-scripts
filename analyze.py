import argparse
import sys
import os
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from scapy.all import rdpcap, IP, DNSQR, sniff
from collections import Counter


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="PCAP File Analyzer")
    parser.add_argument("pcap_file", help="Path to the PCAP file")
    return parser.parse_args()


def read_pcap(pcap_file):
    """Read and return packets from a pcap file."""
    try:
        return rdpcap(pcap_file)
    except Exception as e:
        print(f"Error reading {pcap_file}: {e}")
        sys.exit(1)


def clear_screen():
    """Clears the terminal screen."""
    os.system("cls" if os.name == "nt" else "clear")


def unique_ips(packets):
    """Display unique IP addresses from packets."""
    ips = Counter()
    for packet in packets:
        if IP in packet:
            ips[packet[IP].src] += 1
            ips[packet[IP].dst] += 1
    return sorted(ips)


def unique_domains(packets):
    """Display unique domains from packets."""
    domains = Counter()
    for packet in packets:
        if DNSQR in packet:
            domains[packet[DNSQR].qname.decode("utf-8").rstrip(".")] += 1
    return sorted(domains)


def frequency_analysis(packets):
    """Display frequency analysis of IPs, domains, and ports in a table format."""
    socket_counter = Counter()

    for packet in packets:
        if IP in packet:
            src_socket = f"{packet[IP].src}:{packet[IP].sport}"
            dst_socket = f"{packet[IP].dst}:{packet[IP].dport}"
            socket_counter[src_socket] += 1
            socket_counter[dst_socket] += 1
        if DNSQR in packet:
            domain = packet[DNSQR].qname.decode("utf-8").rstrip(".")
            socket_counter[domain] += 1

    max_length = max(len(socket) for socket in socket_counter.keys())
    format_str = f"{{:<{max_length + 2}}}{{}}"

    print("\nFrequency Analysis (IP:Port or Domain):")
    print(format_str.format("Socket", "Count"))
    print("-" * (max_length + 8))
    for socket, count in socket_counter.most_common()[::-1]:
        print(format_str.format(socket, count))
    print()


def protocol_frequency_analysis(packets):
    """Frequency analysis of protocol"""
    protocol_counter = Counter()

    for packet in packets:
        highest_layer = packet.payload
        while highest_layer.payload:
            highest_layer = highest_layer.payload
        protocol_name = type(highest_layer).__name__

        if protocol_name != "NoPayload":
            protocol_counter[protocol_name] += 1
    if protocol_counter:
        max_length = max(len(protocol) for protocol in protocol_counter.keys())
        format_str = f"{{:<{max_length + 2}}}{{}}"

        print("\nDynamic Application Layer Protocol Frequency Analysis:")
        print(format_str.format("Protocol", "Count"))
        print("-" * (max_length + 8))
        for protocol, count in protocol_counter.most_common():
            print(format_str.format(protocol, count))
    else:
        print("\nNo application layer protocols detected.")


def view_data(packets):
    """View raw data associated with a specified domain or socket."""
    user_input = input("Enter a domain or socket (IP:Port): ").strip()

    for packet in packets:
        if IP in packet and (
            user_input == f"{packet[IP].src}:{packet[IP].sport}"
            or user_input == f"{packet[IP].dst}:{packet[IP].dport}"
        ):
            print(packet.show())
        elif DNSQR in packet and user_input == packet[DNSQR].qname.decode(
            "utf-8"
        ).rstrip("."):
            print(packet.show())


def create_timeline(packets):
    """Create a timeline plot of network requests."""
    data = []

    for packet in packets:
        if IP in packet:
            timestamp = float(packet.time)
            src = packet[IP].src
            dst = packet[IP].dst
            data.append((timestamp, f"{src} -> {dst}"))

    df = pd.DataFrame(data, columns=["Timestamp", "Request"])
    df["Count"] = 1
    df["Timestamp"] = pd.to_datetime(df["Timestamp"], unit="s")
    df.set_index("Timestamp", inplace=True)

    timeline = (
        df.groupby([pd.Grouper(freq="20S"), "Request"]).count().unstack(fill_value=0)
    )
    ax = timeline.plot(kind="area", stacked=True, figsize=(15, 6))
    ax.xaxis.set_major_locator(mdates.SecondLocator(interval=20))
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M:%S"))
    plt.xticks(rotation=45)
    plt.xlabel("Time")
    plt.ylabel("Number of Requests")
    plt.title("Timeline of Network Requests")
    plt.tight_layout()
    plt.show()


def main():
    """Main function to orchestrate pcap analysis."""
    args = parse_arguments()
    packets = read_pcap(args.pcap_file)

    options = {
        "0": clear_screen,
        "1": lambda: unique_ips(packets),
        "2": lambda: unique_domains(packets),
        "3": lambda: frequency_analysis(packets),
        "4": lambda: protocol_frequency_analysis(packets),
        "5": lambda: view_data(packets),
        "6": lambda: create_timeline(packets),
    }

    while True:
        print("PCAP Analysis Options:")
        print("0. Clear screen")
        print("1. Show all unique IP addresses")
        print("2. Show all unique domains")
        print("3. Frequency analysis of socket connections")
        print("4. Frequency analysis of protocols")
        print("5. View raw data transfered to/from a socket or domain")
        print("6. View a graphical connection timeline")
        print("7. Exit")

        choice = input("Enter your choice: ")

        if choice in options:
            result = options[choice]()
            if result:
                for item in result:
                    print(item)
                print()
        elif choice == "7":
            break
        else:
            print("Invalid choice. Please try again.")


if __name__ == "__main__":
    main()
